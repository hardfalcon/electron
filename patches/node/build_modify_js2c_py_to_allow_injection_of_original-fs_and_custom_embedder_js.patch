From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cheng Zhao <zcbenz@gmail.com>
Date: Thu, 11 Apr 2019 17:16:13 +0900
Subject: build: modify js2c.py to allow injection of original-fs and custom
 embedder JS

This patch does two things:
* Updates js2c.py so that original-fs is automatically created with
support for streams by copying the file at build time and making a new
builtin called "original-fs" and "original-fs/streams"
* Updates js2c.py so that //electron can call it as part of its build
process and provide embedder modules (electrons
renderer/browser/worker/sandboxed bootstrap scripts).  These are loaded
through LoadEmbedderJavaScriptSource()

diff --git a/lib/internal/fs/watchers.js b/lib/internal/fs/watchers.js
index 99212fa713bf3f767d4604906e41d9b279447239..4e32a274a63c8244ce3168d0c5cc56203cfe5473 100644
--- a/lib/internal/fs/watchers.js
+++ b/lib/internal/fs/watchers.js
@@ -292,12 +292,13 @@ function emitCloseNT(self) {
 }
 
 // Legacy alias on the C++ wrapper object. This is not public API, so we may
-// want to runtime-deprecate it at some point. There's no hurry, though.
-ObjectDefineProperty(FSEvent.prototype, 'owner', {
-  __proto__: null,
-  get() { return this[owner_symbol]; },
-  set(v) { return this[owner_symbol] = v; },
-});
+if (!'owner' in FSEvent.prototype) {
+  ObjectDefineProperty(FSEvent.prototype, 'owner', {
+ __proto__: null,
+    get() { return this[owner_symbol]; },
+    set(v) { return this[owner_symbol] = v; }
+  });
+}
 
 let kResistStopPropagation;
 
diff --git a/src/node_builtins.cc b/src/node_builtins.cc
index 84815969b6d1faa7cc3ed177e04248d9cb074596..7e4a43a6f13845c8a81bae96ec073ccdfc655999 100644
--- a/src/node_builtins.cc
+++ b/src/node_builtins.cc
@@ -35,6 +35,7 @@ using v8::Value;
 BuiltinLoader::BuiltinLoader()
     : config_(GetConfig()), code_cache_(std::make_shared<BuiltinCodeCache>()) {
   LoadJavaScriptSource();
+  LoadEmbedderJavaScriptSource();
 #ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH
   AddExternalizedBuiltin(
       "internal/deps/cjs-module-lexer/lexer",
diff --git a/src/node_builtins.h b/src/node_builtins.h
index 9f2fbc1e53937448aa27c1f5fe110eabc7edc0df..ba0c926a7968ec6a4cf07a469f1fd9314287a937 100644
--- a/src/node_builtins.h
+++ b/src/node_builtins.h
@@ -124,6 +124,7 @@ class NODE_EXTERN_PRIVATE BuiltinLoader {
 
   // Generated by tools/js2c.py as node_javascript.cc
   void LoadJavaScriptSource();  // Loads data into source_
+  void LoadEmbedderJavaScriptSource();  // Loads embedder data into source_
   UnionBytes GetConfig();       // Return data for config.gypi
 
   std::vector<std::string_view> GetBuiltinIds() const;
diff --git a/tools/js2c.cc b/tools/js2c.cc
index 904fb6fa44d4f56fb67476e937edcbb797d78fe7..28dc4b59898fb5ac02dc55f930613f7a46a8a66e 100644
--- a/tools/js2c.cc
+++ b/tools/js2c.cc
@@ -29,6 +29,7 @@ namespace js2c {
 int Main(int argc, char* argv[]);
 
 static bool is_verbose = false;
+static bool only_js = false;
 
 void Debug(const char* format, ...) {
   va_list arguments;
@@ -213,13 +214,17 @@ void BuiltinLoader::LoadJavaScriptSource() {
   source_ = global_source_map;
 }
 
+void BuiltinLoader::LoadEmbedderJavaScriptSource() {
+  source_ = global_source_map;
+}
+
 void RegisterExternalReferencesForInternalizedBuiltinCode(
   ExternalReferenceRegistry* registry) {
 %.*s
 }
 
 UnionBytes BuiltinLoader::GetConfig() {
-  return UnionBytes(&config_resource);
+  return config_resource ? UnionBytes(&config_resource) : UnionBytes(nullptr);
 }
 
 }  // namespace builtins
@@ -254,10 +259,14 @@ Fragment Format(const Fragments& definitions,
 }
 
 std::vector<char> ReadFileSync(const char* path, size_t size, int* error) {
+  std::string filepath(path);
+  if (filepath.starts_with("//v8"))
+    filepath = "../../" + filepath.substr(2);
+
   uv_fs_t req;
-  Debug("ReadFileSync %s with size %zu\n", path, size);
+  Debug("ReadFileSync %s with size %zu\n", filepath.c_str(), size);
 
-  uv_file file = uv_fs_open(nullptr, &req, path, O_RDONLY, 0, nullptr);
+  uv_file file = uv_fs_open(nullptr, &req, filepath.c_str(), O_RDONLY, 0, nullptr);
   if (req.result < 0) {
     uv_fs_req_cleanup(&req);
     *error = req.result;
@@ -536,7 +545,8 @@ Fragment GetDefinition(const std::string& var, const std::vector<char>& code) {
 int AddModule(const std::string& filename,
               Fragments* definitions,
               Fragments* initializers,
-              Fragments* registrations) {
+              Fragments* registrations,
+              std::function<std::vector<char>(const std::vector<char>&)> read_file_fn = ReadFileSync) {
   Debug("AddModule %s start\n", filename.c_str());
 
   int error = 0;
@@ -544,7 +554,7 @@ int AddModule(const std::string& filename,
   if (error != 0) {
     return error;
   }
-  std::vector<char> code = ReadFileSync(filename.c_str(), file_size, &error);
+  std::vector<char> code = read_file_fn(filename.c_str(), file_size, &error);
   if (error != 0) {
     return error;
   }
@@ -703,6 +713,39 @@ int JS2C(const FileList& js_files,
     if (r != 0) {
       return r;
     }
+
+    // Electron: Expose fs module without asar support.
+    if (filename == "lib/fs.js") {
+      int error = 0;
+      size_t size = GetFileSize(filename, &error);
+      if (error != 0 && error != UV_ENOENT)
+        return error;
+
+      std::function<std::vector<char>(const std::vector<char>&)> ReadFileTransform = [](const char* path, size_t size, int* error) {
+        std::vector<char> code = ReadFileSync(path, size, &error);
+        std::replace(code.begin(), code.end(), "require('internal/fs/", "require('internal/original-fs/");
+        return code;
+      };
+      int r = AddModule("lib/original-fs.js", definitions, initializers, ReadFileTransform)
+      if (r != 0) {
+        return r;
+      }
+    } else if (filename.rfind("lib/internal/fs/")) {
+      // std::equal(prefix.begin(), prefix.end(), toCheck.begin())?
+      std::string original_fs_filename = filename;
+      std::replace(original_fs_filename.begin(), original_fs_filename.end(), "internal/fs/", "internal/original-fs/");
+      
+      std::function<std::vector<char>(const std::vector<char>&)> ReadFileTransform = [](const char* path, size_t size, int* error) {
+        std::vector<char> code = ReadFileSync(path, size, &error);
+        std::replace(code.begin(), code.end(), "require('fs')", "require('original-fs')");
+        return code;
+      };
+
+      int r = AddModule(original_fs_filename, definitions, initializers, ReadFileTransform)
+      if (r != 0) {
+        return r;
+      }
+    }
   }
   for (const auto& filename : mjs_files) {
     int r = AddModule(filename, &definitions, &initializers, &registrations);
@@ -711,12 +754,15 @@ int JS2C(const FileList& js_files,
     }
   }
 
-  assert(FilenameIsConfigGypi(config));
-  // "config.gypi" -> config_raw.
-  int r = AddGypi("config", config, &definitions);
-  if (r != 0) {
-    return r;
+  if (!only_js) {
+    assert(FilenameIsConfigGypi(config));
+    // "config.gypi" -> config_raw.
+    int r = AddGypi("config", config, &definitions);
+    if (r != 0) {
+      return r;
+    }
   }
+
   Fragment out = Format(definitions, initializers, registrations);
   return WriteIfChanged(out, dest);
 }
@@ -742,6 +788,8 @@ int Main(int argc, char* argv[]) {
     std::string arg(argv[i]);
     if (arg == "--verbose") {
       is_verbose = true;
+    } else if (arg == "--only-js") {
+      only_js = true;
     } else if (arg == "--root") {
       if (i == argc - 1) {
         fprintf(stderr, "--root must be followed by a path\n");
@@ -790,23 +838,30 @@ int Main(int argc, char* argv[]) {
     }
   }
 
-  // Should have exactly 3 types: `.js`, `.mjs` and `.gypi`.
-  assert(file_map.size() == 3);
-  auto gypi_it = file_map.find(".gypi");
-  // Currently config.gypi is the only `.gypi` file allowed
-  if (gypi_it == file_map.end() || gypi_it->second.size() != 1 ||
-      !FilenameIsConfigGypi(gypi_it->second[0])) {
-    fprintf(
-        stderr,
-        "Arguments should contain one and only one .gypi file: config.gypi\n");
-    return 1;
-  }
   auto js_it = file_map.find(".js");
   auto mjs_it = file_map.find(".mjs");
-  assert(js_it != file_map.end() && mjs_it != file_map.end());
+  auto gypi_it = file_map.find(".gypi");
 
-  std::sort(js_it->second.begin(), js_it->second.end());
-  std::sort(mjs_it->second.begin(), mjs_it->second.end());
+  if (only_js) {
+    assert(file_map.size() == 1);
+    assert(js_it != file_map.end());
+  } else {
+    // Should have exactly 3 types: `.js`, `.mjs` and `.gypi`.
+    assert(file_map.size() == 3);
+    assert(js_it != file_map.end() && mjs_it != file_map.end());
+
+    std::sort(js_it->second.begin(), js_it->second.end());
+    std::sort(mjs_it->second.begin(), mjs_it->second.end());
+
+    // Currently config.gypi is the only `.gypi` file allowed
+    if (gypi_it == file_map.end() || gypi_it->second.size() != 1 ||
+        !FilenameIsConfigGypi(gypi_it->second[0])) {
+      fprintf(
+          stderr,
+          "Arguments should contain one and only one .gypi file: config.gypi\n");
+      return 1;
+    }
+  }
 
   return JS2C(js_it->second, mjs_it->second, gypi_it->second[0], output);
 }

